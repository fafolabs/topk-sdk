/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface ClientConfig {
  apiKey: string
  region: string
  host?: string
  https?: boolean
}
export interface CreateCollectionOptions {
  name: string
  schema: Record<string, FieldSpec>
}
export interface Collection {
  name: string
  orgId: string
  projectId: string
  schema: Record<string, FieldSpec>
  region: string
}
| { type: 'Text' }
| { type: 'Integer' }
| { type: 'Float' }
| { type: 'Boolean' }
| { type: 'F32Vector', dimension: number }
| { type: 'U8Vector', dimension: number }
| { type: 'BinaryVector', dimension: number }
| { type: 'Bytes' }
| { type: 'KeywordIndex' }
| { type: 'VectorIndex', metric: VectorDistanceMetric }
| { type: 'SemanticIndex', model?: string, embeddingType?: EmbeddingDataType }
Text = 'Text'
Cosine = 'Cosine',
Euclidean = 'Euclidean',
DotProduct = 'DotProduct',
Hamming = 'Hamming'
Float32 = 'Float32',
UInt8 = 'UInt8',
Binary = 'Binary'
And = 'And',
Or = 'Or',
Eq = 'Eq',
Neq = 'Neq',
Lt = 'Lt',
Lte = 'Lte',
Gt = 'Gt',
Gte = 'Gte',
StartsWith = 'StartsWith',
Add = 'Add',
Sub = 'Sub',
Mul = 'Mul',
Div = 'Div'
| { type: 'F32', vector: Array<number> }
| { type: 'U8', vector: Array<number> }
| { type: 'KeywordScore' }
| { type: 'VectorScore', field: string, query: VectorQuery }
| { type: 'SemanticSimilarity', field: string, query: string }
function semanticSimilarity(field: string, query: string): FunctionExpression
function vectorDistance(field: string, query: VectorQuery): FunctionExpression
function bm25Score(): FunctionExpression
| { type: 'Null' }
| { type: 'Field', name: string }
| { type: 'Literal', value: any }
| { type: 'Unary', op: UnaryOperator, expr: LogicalExpression }
| { type: 'Binary', left: LogicalExpression, op: BinaryOperator, right: LogicalExpression }
function field(name: string): LogicalExpression
function match(token: string, field?: string | undefined | null, weight?: number | undefined | null): TextExpression
function select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
| { type: 'Select', exprs: Record<string, LogicalExpression | FunctionExpression> }
| { type: 'Filter', expr: LogicalExpression | TextExpression }
| { type: 'TopK', expr: LogicalExpression, k: number, asc: boolean }
| { type: 'Count' }
| { type: 'Rerank', model?: string, query?: string, fields: Array<string>, topkMultiple?: number }
| { type: 'Terms', all: boolean, terms: Array<Term> }
| { type: 'And', left: TextExpression, right: TextExpression }
| { type: 'Or', left: TextExpression, right: TextExpression }
export interface Term {
  token: string
  field?: string
  weight: number
}
Not = 'Not',
IsNull = 'IsNull',
IsNotNull = 'IsNotNull'
export declare class CollectionsClient {
  list(): Promise<Array<Collection>>
  create(options: CreateCollectionOptions): Promise<Collection>
  delete(name: string): Promise<void>
}
export declare class CollectionClient {
  query(query: Query, lsn?: number | undefined | null): Promise<Array<Record<string, any>>>
  upsert(docs: Array<Record<string, any>>): Promise<number>
  delete(ids: Array<string>): Promise<number>
}
export declare class FieldSpec { }
export declare class LogicalExpression {
  static create(expr: LogicalExpressionUnion): LogicalExpression
  eq(value: any): LogicalExpression
  get expr(): LogicalExpressionUnion
  neq(value: any): LogicalExpression
  lt(value: any): LogicalExpression
  lte(value: any): LogicalExpression
  gt(value: any): LogicalExpression
  gte(value: any): LogicalExpression
  add(other: LogicalExpression): LogicalExpression
  sub(other: LogicalExpression): LogicalExpression
  mul(other: LogicalExpression): LogicalExpression
  div(other: LogicalExpression): LogicalExpression
  and(other: LogicalExpression): LogicalExpression
  or(other: LogicalExpression): LogicalExpression
  startsWith(other: LogicalExpression): LogicalExpression
}
export declare class Query {
  static create(stages: Array<Stage>): Query
  filter(expr: LogicalExpression | TextExpression): Query
  top_k(fieldName: string, k: number, asc?: boolean | undefined | null): Query
  count(): Query
  get stages(): Array<Stage>
}
export declare class TextExpression {
  static create(expr: TextExpressionUnion): TextExpression
  get expr(): TextExpressionUnion
  and(other: TextExpression): TextExpression
  or(other: TextExpression): TextExpression
}
export declare class Client {
  constructor(config: ClientConfig)
  collections(): CollectionsClient
  collection(name: string): CollectionClient
}
