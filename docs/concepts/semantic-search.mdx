---
title: "Semantic search"
---

To find documents based on semantic similarity, use the `semantic_similarity()` function.

With TopK, you can implement vector-powered semantic search in just a few lines of code. No need for third-party embedding models or reranking services.

TopK comes with **built-in embeddings** and **reranking**, removing the need to build your own semantic retrieval pipeline.

---

## Implement semantic search

### 1. Define a collection schema

Adding a [`semantic_index()`](/collections/create#semantic-index) to any [text](/collections/create#text) field in your collection schema enables semantic search capabilities.
This configuration automatically generates embeddings for the specified text fields:

<CodeGroup>

```python Python
from topk_sdk.schema import text, semantic_index

client.collections().create(
    "books",
    schema={
        "title": text().required().index(semantic_index()),
    },
)
```


```typescript Javascript
import { text, semanticIndex } from "topk-js/schema";

await client.collections().create("books", {
  title: text().required().index(semanticIndex()),
});
```

</CodeGroup>

If you want to use your own embeddings instead of TopK's built-in `semantic_index()`, see [Vector Search](/concepts/vector-search).

### 2. Perform a semantic search

To perform a semantic search we'll use the `semantic_similarity()` function to compute the similarity between the query `"catcher in the rye"` and the `title` field.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.semantic_similarity("title", "catcher in the rye")
    )
    .topk(field("title_similarity"), 10)
    .rerank()
)
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.semanticSimilarity("title", "catcher in the rye"),
  })
    .topk(field("title_similarity"), 10)
    .rerank()
);
```

</CodeGroup>

Let's break down the above example:

1. The `semantic_similarity` function computes the similarity between the query `"catcher in the rye"` and the text value stored in the `title` field for each document.
2. TopK performs automatic query embedding under the hood using the model specified in [`semantic_index()`](/collections/create#semantic-index) method.
3. The results are ranked based on similarity, and the top 10 most relevant documents are returned.
4. The optional `.rerank()` call uses a reranking model to improve relevance of the results.

This works **out of the box**â€”no need to manage embeddings, external APIs, or reranking models.

## Combining semantic and keyword search

For certain use cases, you can use a combination of **keyword search** and **semantic search**. After, you can use a custom ranking logic to get the top results.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn, match

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.semantic_similarity("title", "catcher"),
        text_score=fn.bm25_score()  # Keyword-based relevance
    )
    .filter(match("classic"))  # Ensure the book title contains "classic" keyword
    .topk(field("title_similarity") * 0.7 + field("text_score") * 0.3, 10)
)
```


```typescript Javascript
import { select, field, fn, match } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.semanticSimilarity("title", "catcher"),
    text_score: fn.bm25Score(), // Keyword-based relevance
  })
    .filter(match("classic")) // Ensure the book title contains "classic" keyword
    .topk(
      field("title_similarity").mul(0.7).add(field("text_score").mul(0.3)),
      10
    )
);
```

</CodeGroup>

This blends **keyword relevance (BM25)** with **semantic similarity**, ensuring your search results capture both exact matches and contextual meaning with a custom scoring function that's best suited for your use case.

---

## Customization

{/* ### Bring your own embeddings

Using [`semantic_index()`](/collections/create#semantic-index) is not the only way to enable a semantic search in TopK.
You can define a vector field in your schema and use the `vector_distance()` function for semantic search by passing
an embedding to the `vector_distance()` function.

<CodeGroup>

```python Python
from topk_sdk.schema import text, vector, vector_index

client.collections().create(
    "books",
    schema={
        "title": text().required(),
        "title_embedding": f32_vector(1536).index(vector_index(metric="cosine")),  # Custom embeddings
    },
)
```


```typescript Javascript
import { text, vector, vectorIndex } from "topk-js/schema";

await client.collections().create("books", {
  title: text().required(),
  title_embedding: f32Vector({ dimension: 1536 }).index(
    vectorIndex({ metric: "cosine" })
  ), // Custom embeddings
});
```

</CodeGroup>

To query with custom embeddings, use `vector_distance()` function:

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.vector_distance("title_embedding", [0.1, 0.2, 0.3, ...])
    )
    .topk(field("title_similarity"), 10)
)
```


```typescript Javascript
import { select, field, fn } "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.vectorDistance("title_embedding", [0.1, 0.2, 0.3]),
  }).topk(field("title_similarity"), 10)
);
```

</CodeGroup>

Using custom embeddings is useful if:

- You have a **domain-specific embedding model** (e.g., medical, legal, or technical documents).
- You need embeddings that are **consistent across multiple systems**.

For most use cases, TopK's built-in `semantic_index()` is the easiest and most efficient way to implement semantic search.

You can still use our built-in reranking model by calling `.rerank()` on a query with custom embeddings. In this case, you will need to pass the query and fields to `.rerank()` explicitly.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.vector_distance("title_embedding", [0.1, 0.2, 0.3, ...])
    )
    .topk(field("title_similarity"), 10)
    .rerank(
        query="catcher in the rye",
        fields=["title"]
    )
)
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.vectorDistance("title_embedding", [0.1, 0.2, 0.3]),
  })
    .topk(field("title_similarity"), 10)
    .rerank({
      query: "catcher in the rye",
      fields: ["title"],
    })
);
```

</CodeGroup> */}

### Lexical scoring with reranking

You can also use lexical scoring with reranking. This will score documents based on the BM25 score and then use the semantic similarity to rerank the results.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        text_score=fn.bm25_score(),
    )
    .filter(match("catcher in the rye"))
    .topk(field("text_score"), 10)
    .rerank(
        query="catcher in the rye",
        fields=["title"]
    )
)
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    text_score: fn.bm25Score(),
  })
    .filter(match("catcher in the rye"))
    .topk(field("text_score"), 10)
    .rerank({
      query: "catcher in the rye",
      fields: ["title"],
    })
);
```

</CodeGroup>