---
title: "Semantic search"
---

With TopK, you can implement vector-powered **semantic search** in just a few lines of code.

TopK comes with **built-in embeddings** and **reranking**, removing the need for third-party embedding models or custom reranking solutions.

## How to perform a semantic search


In the following example, we'll:

1. Define a collection schema for semantic search
2. Add documents to the collection
3. Perform a semantic search


### Define a collection schema

Semantic search is enabled by adding a [`semantic_index()`](/collections/create#semantic-index) to a text field in the collection schema.
This configuration automatically generates embeddings as well as enables keyword search for the specified text fields:

<CodeGroup>

```python Python
from topk_sdk.schema import text, semantic_index

client.collections().create(
    "books",
    schema={
        "title": text().required().index(semantic_index()),
    },
)
```


```typescript Javascript
import { text, semanticIndex } from "topk-js/schema";

await client.collections().create("books", {
  title: text().required().index(semanticIndex()),
});
```

</CodeGroup>

<Tip>
  If you want to use your own embeddings instead of TopK's built-in `semantic_index()`, see [Vector Search](/concepts/vector-search).
</Tip>

### Add documents to the collection

Let's add some documents to the collection:

<CodeGroup>

```python Python
client.collection("books").upsert(
    [
        {"_id": "gatsby", "title": "The Great Gatsby"},
        {"_id": "1984", "title": "1984"},
        {"_id": "catcher", "title": "The Catcher in the Rye"}
    ],
)
```


```typescript Javascript
await client.collection("books").upsert([
  { _id: "gatsby", title: "The Great Gatsby" },
  { _id: "1984", title: "1984" },
  { _id: "catcher", title: "The Catcher in the Rye" },
]);
```

</CodeGroup>

### Perform a semantic search

To find documents based on semantic similarity, use the `semantic_similarity()` function:

<CodeGroup>

```python Python
from topk_sdk.query import select, field, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.semantic_similarity("title", "classic American novel")
    )
    .topk(field("title_similarity"), 10)
    .rerank()
)

# Example results:

[
  {
    "_id": "2",
    "title": "The Catcher in the Rye",
    "title_similarity": 0.9497610926628113,
    "_rank": 0,
    "_rerank_score": 0.048159245401620865,
  },
  {
    "_id": "1",
    "title": "The Great Gatsby",
    "title_similarity": 0.9480283856391907,
    "_rank": 1,
    "_rerank_score": 0.02818089909851551,
  }
]
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.semanticSimilarity("title", "classic American novel"),
  })
    .topk(field("title_similarity"), 10)
    .rerank()
);

// Example results:

[
  {
    _id: '2',
    title: 'The Catcher in the Rye',
    title_similarity: 0.9497610926628113,
    _rank: 0
    _rerank_score: 0.048159245401620865,
  },
  {
    _id: '1',
    title: 'The Great Gatsby'
    title_similarity: 0.9480283856391907,
    _rank: 1,
    _rerank_score: 0.02818089909851551,
  }
]
```

</CodeGroup>

Let's break down the example above:

1. The `semantic_similarity()` function computes the similarity between the query `"classic American novel"` and the text value stored in the `title` field for each document.
2. TopK performs automatic query embedding under the hood using the model specified in [`semantic_index()`](/collections/create#semantic-index) function.
3. The results are ranked based on similarity, and the top 10 most relevant documents are returned.
4. The optional `.rerank()` call uses a reranking model to improve relevance of the results.
  For more information, see our [Reranking](/concepts/reranking) guide.

This works **out of the box**â€”no need to manage embeddings, external APIs, or third-party reranking models.

## Combining semantic and keyword search

For certain use cases, you might want to use a combination of **keyword search** and **semantic search** and refine the results with reranking.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn, match

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.semantic_similarity("title", "catcher"),
        text_score=fn.bm25_score()  # Keyword-based relevance
    )
    .filter(match("classic"))  # Ensure the book contains the keyword "classic" in any text-indexed field
    .topk(field("title_similarity") * 0.7 + field("text_score") * 0.3, 10)
    .rerank()
)
```


```typescript Javascript
import { select, field, fn, match } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.semanticSimilarity("title", "catcher"),
    text_score: fn.bm25Score(), // Keyword-based relevance
  })
    .filter(match("classic")) // Ensure the book contains the keyword "classic" in any text-indexed field
    .topk(
      field("title_similarity").mul(0.7).add(field("text_score").mul(0.3)),
      10
    )
    .rerank()
);
```

</CodeGroup>

This blends **keyword relevance (BM25)** with **semantic similarity**, ensuring your search results capture both exact matches and contextual meaning with a custom scoring function that's best suited for your use case.

---

## Customization

{/* ### Bring your own embeddings

Using [`semantic_index()`](/collections/create#semantic-index) is not the only way to enable a semantic search in TopK.
You can define a vector field in your schema and use the `vector_distance()` function for semantic search by passing
an embedding to the `vector_distance()` function.

<CodeGroup>

```python Python
from topk_sdk.schema import text, vector, vector_index

client.collections().create(
    "books",
    schema={
        "title": text().required(),
        "title_embedding": f32_vector(1536).index(vector_index(metric="cosine")),  # Custom embeddings
    },
)
```


```typescript Javascript
import { text, vector, vectorIndex } from "topk-js/schema";

await client.collections().create("books", {
  title: text().required(),
  title_embedding: f32Vector({ dimension: 1536 }).index(
    vectorIndex({ metric: "cosine" })
  ), // Custom embeddings
});
```

</CodeGroup>

To query with custom embeddings, use `vector_distance()` function:

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.vector_distance("title_embedding", [0.1, 0.2, 0.3, ...])
    )
    .topk(field("title_similarity"), 10)
)
```


```typescript Javascript
import { select, field, fn } "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.vectorDistance("title_embedding", [0.1, 0.2, 0.3]),
  }).topk(field("title_similarity"), 10)
);
```

</CodeGroup>

Using custom embeddings is useful if:

- You have a **domain-specific embedding model** (e.g., medical, legal, or technical documents).
- You need embeddings that are **consistent across multiple systems**.

For most use cases, TopK's built-in `semantic_index()` is the easiest and most efficient way to implement semantic search.

You can still use our built-in reranking model by calling `.rerank()` on a query with custom embeddings. In this case, you will need to pass the query and fields to `.rerank()` explicitly.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.vector_distance("title_embedding", [0.1, 0.2, 0.3, ...])
    )
    .topk(field("title_similarity"), 10)
    .rerank(
        query="catcher in the rye",
        fields=["title"]
    )
)
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.vectorDistance("title_embedding", [0.1, 0.2, 0.3]),
  })
    .topk(field("title_similarity"), 10)
    .rerank({
      query: "catcher in the rye",
      fields: ["title"],
    })
);
```

</CodeGroup> */}

### Lexical scoring with reranking

To combine lexical scoring with reranking using a custom query, use the `bm25_score()` function to score documents based on the BM25 score and then use the `rerank()` function to rerank the results using a custom query:

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        text_score=fn.bm25_score(),
    )
    .filter(match("catcher in the rye"))
    .topk(field("text_score"), 10)
    .rerank(
        query="catcher in the rye",
        fields=["title"]
    )
)
```


```typescript Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    text_score: fn.bm25Score(),
  })
    .filter(match("catcher in the rye"))
    .topk(field("text_score"), 10)
    .rerank({
      query: "catcher in the rye",
      fields: ["title"],
    })
);
```

</CodeGroup>